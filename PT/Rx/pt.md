# 데이터 흐름을
# 일관된 방식으로
# 안전하게 처리하는
# 라이브러리 RxJS

---

# 데이터 처리 중 에러가 발생하는 상황

---

## 1. 변수 사용
- 값이 변한다는 상태는 에러가 발생하는 상황을 만드는 
가장 기본적인 조건이다.
= 어떤 상황이 일어날 수 있는 지에 대한 가능성을 
항상 염두해두어야 한다.

---

## 2. 수 많은 분기문과 반복문 제어
- 코드의 흐름을 읽기 어렵게 만들고
logic이 존재하는 목적을 알기 어렵게 만든다.
= 테스트를 하기 어렵다. 
= 문제가 발생했을 때 원인을 파악하기 힘들어진다.

---

## 3. 동기와 비동기
동기: 프로그램과 코드의 흐름이 일치, 하지만 프로세스를 독점 (다른 일을 못함)
비동기: 한 프로세스 내에서 다양한 일이 동시에 처리될 수 있음, 제어하기 쉽지 않음

---

# 상태 머신(FSM)

- 그림이 없네.. 그리자
- Event 발생
- 입력(input) -> [상태(state1) - 전이 (transition) -> 상태(state2)] -> 출력(output)

---

# 상태 머신에서의 에러

---

## 1. 입력에 대한 에러
- 어려움: 데이터 형태에 따라서 그 형태에 맞게 처리를 해주어야 한다.
ex) callback, event, promise, iterator 등..

- 각 형태가 갖고 있는 예외적인 상황을 처리해주어야 한다.

---

## 2. Transition 과정에 대한 에러
- side effect
- logic 에러 등

---


# Rx
- 비동기와 이벤트 기반 프로그램을 작성하기 위해 나온 도구
- 반응형 프로그래밍
    - 외부 환경이 프로그램 안으로 요청을 밀어넣고 그 요청이 처리되는 형태
    ( 푸시 시나리오 )
    - 반대는 프로그램이 외부 환경에 접근을 직접 하고 원하는 결과를 얻어와 처리하는 형태가 있다.
    ( 풀 시나리오 )
    - 자극이 있어야만 반응하는 수동성을 지닌다.
- 그림이 필요

---

# Rx를 사용하면 좋은 이유
1. 푸시 시나리오를 통한 상태 관리를 쉽게 할 수 있다.
2. 감시자 패턴의 장점인 Loosely Coupling 이 적용됨
3. 기존 감시자 패턴의 부족한 부분 보완
    - 일관성 있게 구현
    - error, complete와 같은 로직을 더 쉽게 처리
4. 인터페이스의 단일화
    - Observable 클래스를 통해 추상화
5. 함수형 프로그래밍 기반의 흐름

---

# Rx를 구성하는 요소

---
## Observable

- Observer가 다루는 데이터
- 시간을 축으로 연속적인 데이터를 저장한 컬렉션(= 스트림)
- 비동기 상태로 다루는 다양한 데이터들을 Rx에서 하나의 형태로 다룰 수 있게 해주는 인터페이스 역할
- 다루는 데이터의 형태 또는 목적에 따라 Observable을 생성해주는 함수를 다양하게 제공 
& 직접 생성도 가능 (비추)

## Observable 의 성질

1. read-only
2. reactive
3. immutable

---

## Operator 

- Observable을 다루는 함수
1. 새로운 Observable을 반환
2. 함수형 프로그래밍 기반 (cc Observable)
3. 반복문과 분기문에 대한 프로세스를 읽기 쉽게 해준다.
4. 양방향 보단 단방향의 흐름 선택

---

## Marble Diagram

- 시간에 따른 데이터 흐름을 추상화
- Observable이 Operator에 의해 다른 스트림으로 변화하는 과정을 표현
- 그림필요

---

-> 이어서 .. 한번 더 :(

위 내용을 코드와 함께 + @ ( 다 하지 못한 주제 )

---

Observer
- Observable 데이터를 소비하는 주체

Subscription
- Push 시나리오 상태를 제어
    - 상태를 전파 또는 전파 상태를 해제

Subject
- Read & Write 가능한 Observable

Scheduler & Thread

Cold vs Hot

Hot Observable = Connectable Observable
- Observer와의 관계가 1:1 vs 1:N
- Cold vs Hot = VOD vs Youtube
= 시청자가 시청하는 시점에 방송이 진행되냐, 시청자와는 상관없이 방송이 진행되냐의 차이

---